/**
 * Thingstead Governance Kernel — Deterministic action scheduler.
 *
 * Implements the deterministic action pipeline:
 *   1. Action arrives
 *   2. Capability check
 *   3. Policy validation
 *   4. State transition
 *   5. Ledger append
 *   6. Proof generation (if gate)
 *
 * No step is skippable or reorderable. The scheduler processes
 * queued actions through the pipeline in strict sequence order.
 */

import { enforcePolicy } from "./policyEnforcer.js";
import { appendEntry, LedgerEventType } from "./ledger.js";
import { checkAccess, resolveActorType } from "./access.js";

// ---------------------------------------------------------------------------
// Pipeline step results
// ---------------------------------------------------------------------------

export const PipelineResult = Object.freeze({
  OK: "ok",
  POLICY_BLOCKED: "policy_blocked",
  CAPABILITY_DENIED: "capability_denied",
  CONFLICT: "conflict",
  ERROR: "error",
});

// ---------------------------------------------------------------------------
// Action type mapping to ledger events
// ---------------------------------------------------------------------------

const ACTION_TO_LEDGER_EVENT = {
  SUBMIT_ADVISORY: null, // Advisory drafts don't get ledger entries (they're in the openclaw namespace).
  HEARTBEAT: null,       // Heartbeats are operational, not governance events.
};

// ---------------------------------------------------------------------------
// Deterministic pipeline
// ---------------------------------------------------------------------------

/**
 * Processes a single action through the deterministic pipeline.
 *
 * @param {Object} action - The queued action entry (from queue.js).
 * @param {Object} context - Processing context.
 * @param {Object} [context.policy] - Active governance policy.
 * @param {Array}  [context.ledger] - Current ledger (for appending).
 * @param {string} [context.actorId] - Actor ID override.
 * @returns {{ result: string, ledger: Array, entry: Object|null, reason: string|null }}
 */
export function processAction(action, context = {}) {
  const { policy, ledger: currentLedger, actorId } = context;
  let ledger = currentLedger || [];

  // Step 1: Action arrives (already done — action is the input).

  // Step 2: Capability check.
  const effectiveActorId = actorId || action.agentId || "unknown";
  const actorType = resolveActorType(effectiveActorId, action.actorType);
  const accessCheck = checkAccess({
    actorType,
    capabilities: action.capabilities,
    actionType: action.policyAction?.type || action.type,
  });

  if (!accessCheck.allowed) {
    // Log the denied attempt to the ledger.
    try {
      const denyResult = appendEntry(
        ledger,
        LedgerEventType.OVERRIDE_ATTEMPTED,
        {
          action_type: action.type,
          actor_id: effectiveActorId,
          actor_type: actorType,
          denied_capability: accessCheck.capability,
          reason: accessCheck.reason,
        },
        effectiveActorId
      );
      ledger = denyResult.ledger;
    } catch {
      // Non-fatal.
    }

    return {
      result: PipelineResult.CAPABILITY_DENIED,
      ledger,
      entry: null,
      reason: accessCheck.reason,
    };
  }

  // Step 3: Policy validation.
  if (action.policyAction) {
    const enforcement = enforcePolicy(action.policyAction, policy || null);
    if (!enforcement.allowed) {
      // Log the blocked attempt to the ledger.
      try {
        const blockResult = appendEntry(
          ledger,
          LedgerEventType.OVERRIDE_ATTEMPTED,
          {
            action_type: action.type,
            agent_id: action.agentId,
            reason: enforcement.reason,
          },
          actorId || action.agentId || "unknown"
        );
        ledger = blockResult.ledger;
      } catch {
        // Non-fatal.
      }

      return {
        result: PipelineResult.POLICY_BLOCKED,
        ledger,
        entry: null,
        reason: enforcement.reason,
      };
    }
  }

  // Step 4: State transition.
  // The actual state mutation happens outside the scheduler — the caller
  // applies the action to the project state after the pipeline approves it.

  // Step 5: Ledger append (for governance-relevant actions).
  const ledgerEventType = ACTION_TO_LEDGER_EVENT[action.type];
  let entry = null;
  if (ledgerEventType) {
    try {
      const result = appendEntry(
        ledger,
        ledgerEventType,
        action.payload || {},
        actorId || action.agentId || "unknown"
      );
      ledger = result.ledger;
      entry = result.entry;
    } catch {
      // Non-fatal.
    }
  }

  // Step 6: Proof generation (if gate).
  // Gate proofs are generated by the caller using generateGateProof()
  // and bound to the ledger entry via bindProofToPayload().

  return {
    result: PipelineResult.OK,
    ledger,
    entry,
    reason: null,
  };
}

/**
 * Processes a batch of actions through the pipeline in sequence order.
 *
 * @param {Object[]} actions - Array of queued action entries, pre-sorted by sequence.
 * @param {Object} context - Processing context (same as processAction).
 * @returns {{ results: Array, ledger: Array }}
 */
export function processBatch(actions, context = {}) {
  let ledger = context.ledger || [];
  const results = [];

  for (const action of actions) {
    const outcome = processAction(action, { ...context, ledger });
    ledger = outcome.ledger;
    results.push({
      sequence: action.sequence,
      actionType: action.type,
      result: outcome.result,
      reason: outcome.reason,
    });
  }

  return { results, ledger };
}
